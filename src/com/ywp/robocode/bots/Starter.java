package com.ywp.robocode.bots;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;

import robocode.AdvancedRobot;
import robocode.ScannedRobotEvent;
import robocode.util.Utils;

import com.ywp.robocode.SuperSampleBots.SuperMercutio.GunWave;
import com.ywp.robocode.utils.BotTools;
import com.ywp.robocode.utils.MovementWave;

public class Starter extends AdvancedRobot {

	/*
	 * change these statistics to see different graphics.
	 */
	final static boolean PAINT_MOVEMENT=false;
	final static boolean PAINT_GUN=true;

	ArrayList<MovementWave> moveWaves=new ArrayList<MovementWave>();
	ScannedRobotEvent currentTarget = null;
	double lastTargetChange = 0d;
	static final double targetChangeThreshold = 10d;
	
	double enemyEnergy = 0d;
	
	/* (non-Javadoc)
	 * @see robocode.Robot#run()
	 */
	@Override
	public void run() {
		setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		setColors(Color.red,Color.yellow,Color.blue);
 
		//This is the best possible radar lock
		while(true){
			if(getRadarTurnRemainingRadians()==0){
				setTurnRadarRightRadians(Double.POSITIVE_INFINITY);
			}
			execute();
		}
	}

	/* (non-Javadoc)
	 * @see robocode.Robot#onScannedRobot(robocode.ScannedRobotEvent)
	 */
	@Override
	public void onScannedRobot(ScannedRobotEvent event) {
		pickTarget(event);
		if (currentTarget.getName().equals(event.getName())) {
			double energyChange=(enemyEnergy-(enemyEnergy=event.getEnergy()));
			if(energyChange<=3&&energyChange>=0.1){
				logMovementWave(event,energyChange);
			}
			
			/*
			 * Aiming our gun and firing
			 */
			double absBearing=event.getBearingRadians()+getHeadingRadians();
			setTurnGunRightRadians(Utils.normalRelativeAngle(absBearing-getGunHeadingRadians()));
			setFire(Math.min(2.4,Math.min(event.getEnergy()/4,getEnergy()/10)));
			setTurnRadarRightRadians(Utils.normalRelativeAngle(absBearing-getRadarHeadingRadians())*2);
		}
	}

	/* (non-Javadoc)
	 * @see robocode.Robot#onPaint(java.awt.Graphics2D)
	 */
	@Override
	public void onPaint(Graphics2D g) {
		// TODO Auto-generated method stub
		double radius;
		 
		/*
		 * Paints the waves and the imaginary bullets from the movement.
		 */
		if(PAINT_MOVEMENT){
			for(int i=0;i<moveWaves.size();i++){
				MovementWave w=moveWaves.get(i);
				g.setColor(Color.blue);
				radius=(getTime()-w.startTime)*w.speed+w.speed;
				g.drawOval((int)(w.origin.x-radius),(int)(w.origin.y-radius),(int)radius*2,(int)radius*2);
				Point2D.Double hotBullet=BotTools.project(w.origin,radius,w.angle);
				Point2D.Double latBullet=BotTools.project(w.origin,radius,w.angle+w.latVel);
				g.setColor(Color.red);
				g.fillOval((int)hotBullet.x-3,(int)hotBullet.y-3,6,6);
				g.fillOval((int)latBullet.x-3,(int)latBullet.y-3,6,6);
			}
		}
		/*
		 * Just paints the waves for the targeting.
		 */
//		if(PAINT_GUN){
//			for(int i=0;i<gunWaves.size();i++){
//				GunWave w=gunWaves.get(i);
//				g.setColor(Color.blue);
//				radius=(getTime()-w.startTime)*w.speed;
//				g.drawOval((int)(w.origin.x-radius),(int)(w.origin.y-radius),(int)radius*2,(int)radius*2);
//			}
//		}
	}

	/*
	 * This method receives a ScannedRobotEvent and uses that information to create a new wave and place it in
	 * our log. Basically we're going to take all the information we'll need to know later to figure out where
	 * to move to and store it in one object so we can use it easily later.
	 */
	public void logMovementWave(ScannedRobotEvent e,double energyChange){
		double absBearing=e.getBearingRadians()+getHeadingRadians();
		MovementWave w=new MovementWave();
		//This is the spot that the enemy was in when they fired.
		w.origin=BotTools.project(new Point2D.Double(getX(),getY()),e.getDistance(),absBearing);
		//20-3*bulletPower is the formula to find a bullet's speed.
		w.speed=20-3*energyChange;
		//The time at which the bullet was fired.
		w.startTime=getTime();
		//The absolute bearing from the enemy to us can be found by adding Pi to our absolute bearing.
		w.angle=Utils.normalRelativeAngle(absBearing+Math.PI);
		/*
		 * Our lateral velocity, used to calculate where a bullet fired with linear targeting would be.
		 * Note that the speed has already been factored into the calculation.
		 */
		w.latVel=(getVelocity()*Math.sin(getHeadingRadians()-w.angle))/w.speed;
		//This actually adds the wave to the list.
		moveWaves.add(w);
	}
	/*
	 * This method looks at all the directions we could go, then rates them based on how close they will take us
	 * to simulated bullets fired with both linear and head-on targeting generated by the waves we have logged.
	 * It is the core of our movement.
	 */
	public void chooseDirection(Point2D.Double enemyLocation){
		MovementWave w;
		//This for loop rates each angle individually
		double bestRating=Double.POSITIVE_INFINITY;
		for(double moveAngle=0;moveAngle<Math.PI*2;moveAngle+=Math.PI/16D){
			double rating=0;
 
			//Movepoint is position we would be at if we were to move one robot-length in the given direction. 
			Point2D.Double movePoint=BotTools.project(new Point2D.Double(getX(),getY()),36,moveAngle);
 
			/*
			 * This loop will iterate through each wave and add a risk for the simulated bullets on each one
			 * to the total risk for this angle.
			 */
			for(int i=0;i<moveWaves.size();i++){
				w=moveWaves.get(i);
 
				//This part will remove waves that have passed our robot, so we no longer keep taking into account old ones
				if(new Point2D.Double(getX(),getY()).distance(w.origin)<(getTime()-w.startTime)*w.speed+w.speed){
					moveWaves.remove(w);
				}
				else{
					/*
					 * This adds two risks for each wave: one based on the distance from where a head-on targeting
					 * bullet would be, and one for where a linear targeting bullet would be.
					 */
					rating+=1D/Math.pow(movePoint.distance(BotTools.project(w.origin,movePoint.distance(w.origin),w.angle)),2);
					rating+=1D/Math.pow(movePoint.distance(BotTools.project(w.origin,movePoint.distance(w.origin),w.angle+w.latVel)),2);
				}
			}
			//This adds a risk associated with being too close to the other robot if there are no waves.
			if(moveWaves.size()==0){
				rating=1D/Math.pow(movePoint.distance(enemyLocation),2);
			}
			//This part tells us to go in the direction if it is better than the previous best option and is reachable.
			if(rating<bestRating && new Rectangle2D.Double(50,50,getBattleFieldWidth()-100,getBattleFieldHeight()-100).contains(movePoint)){
				bestRating=rating;
				/*
				 * These next three lines are a very codesize-efficient way to 
				 * choose the best direction for moving to a point.
				 */
				int pointDir;
				setAhead(1000*(pointDir=(Math.abs(moveAngle-getHeadingRadians())<Math.PI/2?1:-1)));
				setTurnRightRadians(Utils.normalRelativeAngle(moveAngle+(pointDir==-1?Math.PI:0)-getHeadingRadians()));
			}
		}// end for
	}
	
	private void pickTarget(ScannedRobotEvent target) {
		if (currentTarget == null) {
			setTarget(target);
		}
		
		if (lastTargetChange + targetChangeThreshold > this.getTime()) {
			if (! currentTarget.getName().equals(target.getName())) {
				if (target.getDistance() < currentTarget.getDistance()) {
					setTarget(target);
				}
			}
		}
	}
	
	private void setTarget (ScannedRobotEvent target) {
		currentTarget = target;
		lastTargetChange = this.getTime();
		enemyEnergy = target.getEnergy();		
	}
 }
